# Blocking / Non-blocking / Async I/O 모델

## 핵심 요약
- **Blocking I/O**: 호출한 함수가 작업 완료 시점까지 **대기**  
- **Non-blocking I/O**: 호출 즉시 반환, 작업 준비가 안 됐으면 **즉시 실패/재시도**  
- **Asynchronous I/O**: 요청 후 커널이 알아서 처리, **완료 시점에 알림/콜백**  

---

## 상세 설명

### 1. Blocking I/O
- **동작 방식**  
  - I/O 요청을 하면 **데이터 준비 & 복사 완료**까지 프로세스/스레드가 블록(block) 상태로 대기  
  - CPU가 다른 작업을 수행하지 못하고 멈춤  
- **장점**: 구현이 단순, 직관적  
- **단점**: 응답 지연, 리소스 활용 비효율  

---

### 2. Non-blocking I/O
- **동작 방식**  
  - I/O 요청 시 즉시 반환  
  - 데이터 준비가 안 됐으면 에러 코드(e.g., `EAGAIN`) 반환  
  - 애플리케이션이 **반복적으로 재시도(polling)** 해야 함  
- **장점**: CPU가 대기하지 않고 다른 작업 가능  
- **단점**: 반복 확인(polling)으로 불필요한 자원 낭비  

---

### 3. Asynchronous I/O
- **동작 방식**  
  - I/O 요청 후 즉시 반환  
  - 커널이 작업 완료 시점에 **이벤트, 시그널, 콜백**을 통해 결과 전달  
  - 애플리케이션은 완료 시점에만 반응  
- **장점**: CPU 활용 극대화, 대규모 동시 처리에 적합 (예: Node.js, epoll)  
- **단점**: 구현 복잡, 디버깅 어려움  

---

## 비교표

| 모델 | 동작 방식 | 장점 | 단점 | 활용 예시 |
|------|-----------|------|------|-----------|
| Blocking I/O | 완료될 때까지 대기 | 단순, 직관적 | 대기 시간 낭비 | 전통적인 파일 읽기/쓰기 |
| Non-blocking I/O | 즉시 반환, 준비 안 되면 재시도 | 대기 없음, 병행 작업 가능 | 반복 확인으로 비효율 | `fcntl(O_NONBLOCK)` |
| Async I/O | 완료 시 알림/콜백 | 효율적, 대규모 동시성 처리 | 구현 복잡 | epoll, kqueue, Node.js |

