# 트리(Tree), BST, AVL, Red-Black Tree

## 1. 기본 개념
- **트리(Tree)**
  - 계층적(hierarchical) 구조를 표현하는 자료구조
  - 루트(root)에서 시작해 부모-자식 관계로 연결
  - 사이클이 없는 그래프
- **이진 탐색 트리(Binary Search Tree, BST)**
  - 각 노드 기준으로 왼쪽 서브트리 값 < 노드 값 < 오른쪽 서브트리 값
  - 탐색, 삽입, 삭제 평균 시간 복잡도: O(log n), 최악: O(n)

---

## 2. AVL 트리
- **정의**
  - BST의 일종으로 **균형 인수(Balance Factor = 왼쪽 높이 - 오른쪽 높이)**가 -1, 0, 1만 허용
  - 삽입/삭제 시 회전을 통해 항상 균형 유지
- **장점**
  - 항상 O(log n) 탐색 보장
- **단점**
  - 삽입/삭제 시 회전 비용 발생
- **시간 복잡도**
  - 탐색: O(log n)
  - 삽입/삭제: O(log n) (회전 포함)

---

## 3. 레드-블랙 트리 (Red-Black Tree)
- **정의**
  - 이진 탐색 트리 기반의 **자기 균형 트리(Self-Balancing BST)**
  - 각 노드에 Red/Black 색상을 부여하여 균형 유지
- **규칙**
  1. 루트는 항상 Black
  2. 모든 리프(NIL)는 Black
  3. Red 노드의 자식은 모두 Black (Red-Red 연속 불가)
  4. 루트에서 리프까지 모든 경로의 Black 노드 개수 동일
- **장점**
  - 삽입/삭제가 AVL보다 빠름 (회전 수 적음)
- **단점**
  - 탐색 성능은 AVL보다 약간 떨어질 수 있음
- **시간 복잡도**
  - 탐색/삽입/삭제: O(log n)

---

## 4. 시간 복잡도 비교

| 자료구조          | 탐색(Search) | 삽입(Insert) | 삭제(Delete) |
|------------------|--------------|--------------|--------------|
| 일반 BST         | O(log n) 평균 / O(n) 최악 | O(log n) 평균 / O(n) 최악 | O(log n) 평균 / O(n) 최악 |
| AVL 트리         | O(log n) | O(log n) | O(log n) |
| Red-Black 트리   | O(log n) | O(log n) | O(log n) |

---

## 5. 활용 예시
- **트리(Tree)**: 파일 시스템, 계층 구조 표현
- **BST**: 정렬된 데이터 관리, 탐색 기반 문제
- **AVL 트리**: 탐색 성능 최적화 필요한 경우 (DB 인덱스 등)
- **Red-Black 트리**: 삽입/삭제가 잦은 경우 (언어 라이브러리 Set, Map 구현에 사용 - C++ STL `map`, Java `TreeMap` 등)

---

## 6. 요약
- **트리**: 계층 구조 표현 기본 자료구조  
- **BST**: 정렬된 데이터 저장 및 탐색에 유리하나 최악 성능 보장 불가  
- **AVL**: 항상 균형 유지 → 탐색에 강점  
- **Red-Black**: 덜 엄격한 균형 유지 → 삽입/삭제에 강점, 표준 라이브러리에 널리 사용  
