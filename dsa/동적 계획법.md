# 동적 계획법 (Dynamic Programming, DP)

## 기본 개념
- **정의**: 큰 문제를 작은 부분 문제(subproblem)로 나누어 해결하고, 그 결과를 저장하여 같은 문제를 반복 계산하지 않도록 하는 알고리즘 기법.
- **핵심 아이디어**:  
  - Overlapping Subproblems (부분 문제의 반복)  
  - Optimal Substructure (최적 부분 구조)  
- **접근 방식**:  
  - Top-Down (메모이제이션, 재귀 기반)  
  - Bottom-Up (테이블 기반 반복문)

---

## 대표 예시 알고리즘

### 피보나치 수열 (Fibonacci Sequence)
- **개념**: F(n) = F(n-1) + F(n-2), 단 F(0)=0, F(1)=1
- **시간복잡도**:  
  - 단순 재귀: O(2ⁿ)  
  - DP 적용: O(n)  
- **특징**: DP의 대표적인 입문 문제. 메모이제이션/탑다운, 바텀업 모두 가능.

### 배낭 문제 (Knapsack Problem)
- **개념**: 제한된 용량(capacity) 안에서 가치(value)를 최대화하는 물건 선택 문제.
- **점화식 (0-1 Knapsack)**:  
  - if w[i] ≤ W: dp[i][W] = max(dp[i-1][W], dp[i-1][W-w[i]] + v[i])  
  - else: dp[i][W] = dp[i-1][W]  
- **시간복잡도**: O(n × W)  
- **특징**: 최적화 문제의 대표 예시. 자원 배분 문제에 응용.

### 최단 경로 (Floyd-Warshall, Dijkstra with DP)
- **개념**: 그래프에서 최단 경로를 찾는 문제. Floyd-Warshall은 DP 기반의 전형적인 예시.
- **시간복잡도 (Floyd-Warshall)**: O(n³)  
- **특징**: 모든 정점 쌍 최단 경로 문제에 적용 가능.

---

## 시간 복잡도 정리
| 문제 유형         | 단순 방법 | DP 적용 후 |
|------------------|-----------|------------|
| 피보나치 수열    | O(2ⁿ)     | O(n)       |
| LCS              | O(2ⁿ)     | O(n × m)   |
| 배낭 문제        | 지수적    | O(n × W)   |
| 플로이드-워셜    | -         | O(n³)      |

---

## 활용 예시
- 문자열 처리 (LCS, 편집 거리 Edit Distance)
- 최적화 문제 (Knapsack, 자원 배분)
- 그래프 알고리즘 (최단 경로, 경로 수 계산)
- 게임 이론 (최적 전략 계산)
- 확률/통계 문제 (경우의 수, 조합 계산)

---

## 요약
- DP는 큰 문제를 작은 부분 문제로 분할해 해결.  
- 중복 계산을 줄이기 위해 결과를 저장.  
- 탑다운(재귀+메모이제이션), 바텀업(테이블 채우기) 두 방식 존재.  
- 최적화, 경로 탐색, 문자열 문제 등 다양한 분야에 활용됨.
