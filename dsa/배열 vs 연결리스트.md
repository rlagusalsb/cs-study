# 배열(Array) vs 연결 리스트(Linked List)

## 1. 메모리 구조
- **배열(Array)**
  - 연속된 메모리 공간에 원소가 저장됨
  - 인덱스로 O(1) 접근 가능
- **연결 리스트(Linked List)**
  - 메모리 공간이 연속적이지 않아도 노드와 포인터로 연결
  - 특정 원소 접근 시 순차 탐색 필요 → O(n)

---

## 2. 크기 변경
- **배열**
  - 크기 고정, 변경 불가
  - 확장하려면 새로운 배열을 만들어 복사해야 함
- **연결 리스트**
  - 크기 동적, 삽입/삭제로 자유롭게 변경 가능

---

## 3. 접근 속도
- **배열**
  - 인덱스로 임의 접근(Random Access) 가능 → O(1)
- **연결 리스트**
  - k번째 원소 접근 시 처음부터 순차 탐색해야 함 → O(n)

---

## 4. 삽입 / 삭제
- **배열**
  - 중간에 원소 추가/삭제 시 뒤의 모든 원소 이동 필요 → O(n)
- **연결 리스트**
  - 포인터(참조)만 수정하면 됨 → O(1) (단, 삽입/삭제 위치 찾는 데 O(n))

---

## 5. 메모리 효율
- **배열**
  - 데이터만 저장 → 메모리 사용 효율적
- **연결 리스트**
  - 데이터 + 포인터 저장 필요 → 메모리 오버헤드 발생

---

## 6. 시간 복잡도 비교

| 연산        | 배열 (Array) | 연결 리스트 (Linked List) |
|-------------|--------------|---------------------------|
| 접근 (Access) | O(1) | O(n) |
| 탐색 (Search) | O(n) | O(n) |
| 삽입 (Insert) | O(n) | O(1) (탐색 제외) |
| 삭제 (Delete) | O(n) | O(1) (탐색 제외) |

---

## 7. 활용 예시
- **배열**
  - 데이터 개수가 고정적이고 빠른 접근이 필요한 경우
  - 예: 정렬, 해시 테이블의 내부 버킷
- **연결 리스트**
  - 삽입/삭제가 잦고 데이터 크기가 자주 변하는 경우
  - 예: 큐(Queue), 스택(Stack), 그래프 인접 리스트 표현

---

## 8. 요약
- **배열(Array)** 은 *빠른 접근*에 유리하지만 크기가 고정적이고 삽입/삭제가 느리다.  
- **연결 리스트(Linked List)** 는 *삽입/삭제*에 유리하지만 접근 속도가 느리고 메모리 오버헤드가 있다.  
